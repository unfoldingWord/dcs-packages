/* tslint:disable */
/* eslint-disable */
/**
 * DCS (Gitea) API.
 * This documentation describes the DCS (Gitea) API.
 *
 * OpenAPI spec version: 1.16.7+dcs
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { APIError } from '../models';
import { AddCollaboratorOption } from '../models';
import { AnnotatedTag } from '../models';
import { Attachment } from '../models';
import { Branch } from '../models';
import { BranchProtection } from '../models';
import { CombinedStatus } from '../models';
import { Commit } from '../models';
import { CommitStatus } from '../models';
import { ContentsResponse } from '../models';
import { CreateBranchProtectionOption } from '../models';
import { CreateBranchRepoOption } from '../models';
import { CreateFileOptions } from '../models';
import { CreateForkOption } from '../models';
import { CreateHookOption } from '../models';
import { CreateKeyOption } from '../models';
import { CreatePullRequestOption } from '../models';
import { CreatePullReviewOptions } from '../models';
import { CreateReleaseOption } from '../models';
import { CreateRepoOption } from '../models';
import { CreateStatusOption } from '../models';
import { CreateTagOption } from '../models';
import { CreateWikiPageOptions } from '../models';
import { DeleteFileOptions } from '../models';
import { DeployKey } from '../models';
import { DismissPullReviewOptions } from '../models';
import { EditAttachmentOptions } from '../models';
import { EditBranchProtectionOption } from '../models';
import { EditGitHookOption } from '../models';
import { EditHookOption } from '../models';
import { EditPullRequestOption } from '../models';
import { EditReleaseOption } from '../models';
import { EditRepoOption } from '../models';
import { FileDeleteResponse } from '../models';
import { FileResponse } from '../models';
import { GenerateRepoOption } from '../models';
import { GitBlobResponse } from '../models';
import { GitHook } from '../models';
import { GitTreeResponse } from '../models';
import { Hook } from '../models';
import { IssueTemplate } from '../models';
import { MergePullRequestOption } from '../models';
import { MigrateRepoOptions } from '../models';
import { Note } from '../models';
import { PullRequest } from '../models';
import { PullReview } from '../models';
import { PullReviewComment } from '../models';
import { PullReviewRequestOptions } from '../models';
import { Reference } from '../models';
import { Release } from '../models';
import { RepoTopicOptions } from '../models';
import { Repository } from '../models';
import { SearchResults } from '../models';
import { SubmitPullReviewOptions } from '../models';
import { Tag } from '../models';
import { Team } from '../models';
import { TopicName } from '../models';
import { TopicResponse } from '../models';
import { TrackedTime } from '../models';
import { TransferRepoOption } from '../models';
import { UpdateFileOptions } from '../models';
import { User } from '../models';
import { WatchInfo } from '../models';
import { WikiCommitList } from '../models';
import { WikiPage } from '../models';
import { WikiPageMetaData } from '../models';
/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling acceptRepoTransfer.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling acceptRepoTransfer.');
            }
            const localVarPath = `/repos/{owner}/{repo}/transfer/accept`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork: async (owner: string, repo: string, body?: CreateForkOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createFork.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling createFork.');
            }
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo: async (templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateOwner' is not null or undefined
            if (templateOwner === null || templateOwner === undefined) {
                throw new RequiredError('templateOwner','Required parameter templateOwner was null or undefined when calling generateRepo.');
            }
            // verify required parameter 'templateRepo' is not null or undefined
            if (templateRepo === null || templateRepo === undefined) {
                throw new RequiredError('templateRepo','Required parameter templateRepo was null or undefined when calling generateRepo.');
            }
            const localVarPath = `/repos/{template_owner}/{template_repo}/generate`
                .replace(`{${"template_owner"}}`, encodeURIComponent(String(templateOwner)))
                .replace(`{${"template_repo"}}`, encodeURIComponent(String(templateRepo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAnnotatedTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getAnnotatedTag.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getAnnotatedTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/tags/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getBlob.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getBlob.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getBlob.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/blobs/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTree.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling getTree.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling getTree.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/trees/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listForks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling listForks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling rejectRepoTransfer.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling rejectRepoTransfer.');
            }
            const localVarPath = `/repos/{owner}/{repo}/transfer/reject`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator: async (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoAddCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoAddTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoAddTopic.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoAddTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling repoAddTopic.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCheckCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCheckCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoCheckCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCheckTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCheckTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoCheckTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch: async (owner: string, repo: string, body?: CreateBranchRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection: async (owner: string, repo: string, body?: CreateBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile: async (body: CreateFileOptions, owner: string, repo: string, filepath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoCreateFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook: async (owner: string, repo: string, body?: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey: async (owner: string, repo: string, body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest: async (owner: string, repo: string, body?: CreatePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview: async (body: CreatePullReviewOptions, owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoCreatePullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests: async (body: PullReviewRequestOptions, owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreatePullReviewRequests.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoCreatePullReviewRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease: async (owner: string, repo: string, body?: CreateReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {Blob} attachment 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachmentForm: async (attachment: Blob, owner: string, repo: string, id: number, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachment' is not null or undefined
            if (attachment === null || attachment === undefined) {
                throw new RequiredError('attachment','Required parameter attachment was null or undefined when calling repoCreateReleaseAttachmentForm.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateReleaseAttachmentForm.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateReleaseAttachmentForm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoCreateReleaseAttachmentForm.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus: async (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateStatus.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateStatus.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoCreateStatus.');
            }
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag: async (owner: string, repo: string, body?: CreateTagOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage: async (owner: string, repo: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoCreateWikiPage.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoCreateWikiPage.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/new`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDelete.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDelete.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteBranch.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling repoDeleteBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoDeleteBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteCollaborator.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteCollaborator.');
            }
            // verify required parameter 'collaborator' is not null or undefined
            if (collaborator === null || collaborator === undefined) {
                throw new RequiredError('collaborator','Required parameter collaborator was null or undefined when calling repoDeleteCollaborator.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile: async (body: DeleteFileOptions, owner: string, repo: string, filepath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoDeleteFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteKey.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDeletePullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeletePullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests: async (body: PullReviewRequestOptions, owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeletePullReviewRequests.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDeletePullReviewRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoDeleteReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteReleaseByTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteReleaseByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoDeleteReleaseByTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoDeleteTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTeam.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling repoDeleteTeam.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteTopic.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling repoDeleteTopic.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDeleteWikiPage.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDeleteWikiPage.');
            }
            // verify required parameter 'pageName' is not null or undefined
            if (pageName === null || pageName === undefined) {
                throw new RequiredError('pageName','Required parameter pageName was null or undefined when calling repoDeleteWikiPage.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview: async (body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDismissPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoDismissPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit's diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {string} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch: async (owner: string, repo: string, sha: string, diffType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDownloadCommitDiffOrPatch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDownloadCommitDiffOrPatch.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoDownloadCommitDiffOrPatch.');
            }
            // verify required parameter 'diffType' is not null or undefined
            if (diffType === null || diffType === undefined) {
                throw new RequiredError('diffType','Required parameter diffType was null or undefined when calling repoDownloadCommitDiffOrPatch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch: async (owner: string, repo: string, index: number, diffType: string, binary?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoDownloadPullDiffOrPatch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoDownloadPullDiffOrPatch.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoDownloadPullDiffOrPatch.');
            }
            // verify required parameter 'diffType' is not null or undefined
            if (diffType === null || diffType === undefined) {
                throw new RequiredError('diffType','Required parameter diffType was null or undefined when calling repoDownloadPullDiffOrPatch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit: async (owner: string, repo: string, body?: EditRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEdit.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEdit.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection: async (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoEditBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook: async (owner: string, repo: string, id: string, body?: EditGitHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook: async (owner: string, repo: string, id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest: async (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditPullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditPullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoEditPullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease: async (owner: string, repo: string, id: number, body?: EditReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoEditReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoEditReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage: async (owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoEditWikiPage.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoEditWikiPage.');
            }
            // verify required parameter 'pageName' is not null or undefined
            if (pageName === null || pageName === undefined) {
                throw new RequiredError('pageName','Required parameter pageName was null or undefined when calling repoEditWikiPage.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGet.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGet.');
            }
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with &#x27;path&#x27;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits: async (owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetAllCommits.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetAllCommits.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sha !== undefined) {
                localVarQueryParameter['sha'] = sha;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive: async (owner: string, repo: string, archive: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetArchive.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetArchive.');
            }
            // verify required parameter 'archive' is not null or undefined
            if (archive === null || archive === undefined) {
                throw new RequiredError('archive','Required parameter archive was null or undefined when calling repoGetArchive.');
            }
            const localVarPath = `/repos/{owner}/{repo}/archive/{archive}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetAssignees.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetAssignees.');
            }
            const localVarPath = `/repos/{owner}/{repo}/assignees`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetBranch.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetBranch.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling repoGetBranch.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetBranchProtection.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling repoGetBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetByID.');
            }
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef: async (owner: string, repo: string, ref: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoGetCombinedStatusByRef.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/status`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetContents.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetContents.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetContents.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList: async (owner: string, repo: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetContentsList.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetContentsList.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig: async (owner: string, repo: string, filepath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetEditorConfig.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetEditorConfig.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetEditorConfig.');
            }
            const localVarPath = `/repos/{owner}/{repo}/editorconfig/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetGitHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetGitHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetGitHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetIssueTemplates.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetIssueTemplates.');
            }
            const localVarPath = `/repos/{owner}/{repo}/issue_templates`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetKey.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetLanguages.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetLanguages.');
            }
            const localVarPath = `/repos/{owner}/{repo}/languages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetNote.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetNote.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoGetNote.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/notes/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullRequestCommits.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullRequestCommits.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullRequestCommits.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoGetPullReviewComments.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetPullReviewComments.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetRawFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetRawFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoGetRawFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/raw/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetRelease.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetRelease.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetRelease.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoGetReleaseAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling repoGetReleaseAttachment.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetReleaseByTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetReleaseByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoGetReleaseByTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetReviewers.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetReviewers.');
            }
            const localVarPath = `/repos/{owner}/{repo}/reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetSingleCommit.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetSingleCommit.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoGetSingleCommit.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetTag.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling repoGetTag.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetWikiPage.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetWikiPage.');
            }
            // verify required parameter 'pageName' is not null or undefined
            if (pageName === null || pageName === undefined) {
                throw new RequiredError('pageName','Required parameter pageName was null or undefined when calling repoGetWikiPage.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions: async (owner: string, repo: string, pageName: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetWikiPageRevisions.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetWikiPageRevisions.');
            }
            // verify required parameter 'pageName' is not null or undefined
            if (pageName === null || pageName === undefined) {
                throw new RequiredError('pageName','Required parameter pageName was null or undefined when calling repoGetWikiPageRevisions.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/revisions/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoGetWikiPages.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoGetWikiPages.');
            }
            const localVarPath = `/repos/{owner}/{repo}/wiki/pages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListAllGitRefs.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListAllGitRefs.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListBranchProtection.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListBranchProtection.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListBranches.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListBranches.');
            }
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListCollaborators.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListCollaborators.');
            }
            const localVarPath = `/repos/{owner}/{repo}/collaborators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListGitHooks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListGitHooks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/git`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs: async (owner: string, repo: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListGitRefs.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListGitRefs.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoListGitRefs.');
            }
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListHooks.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListHooks.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys: async (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListKeys.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListKeys.');
            }
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (keyId !== undefined) {
                localVarQueryParameter['key_id'] = keyId;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests: async (owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListPullRequests.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListPullRequests.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (milestone !== undefined) {
                localVarQueryParameter['milestone'] = milestone;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListPullReviews.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListPullReviews.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoListPullReviews.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListReleaseAttachments.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListReleaseAttachments.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoListReleaseAttachments.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases: async (owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListReleases.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListReleases.');
            }
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }

            if (preRelease !== undefined) {
                localVarQueryParameter['pre-release'] = preRelease;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStargazers.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStargazers.');
            }
            const localVarPath = `/repos/{owner}/{repo}/stargazers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses: async (owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStatuses.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStatuses.');
            }
            // verify required parameter 'sha' is not null or undefined
            if (sha === null || sha === undefined) {
                throw new RequiredError('sha','Required parameter sha was null or undefined when calling repoListStatuses.');
            }
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef: async (owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListStatusesByRef.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListStatusesByRef.');
            }
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling repoListStatusesByRef.');
            }
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListSubscribers.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListSubscribers.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscribers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTags.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTags.');
            }
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTeams.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTeams.');
            }
            const localVarPath = `/repos/{owner}/{repo}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoListTopics.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoListTopics.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest: async (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoMergePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoMergePullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoMergePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate: async (body?: MigrateRepoOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoMirrorSync.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoMirrorSync.');
            }
            const localVarPath = `/repos/{owner}/{repo}/mirror-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoPullRequestIsMerged.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoPullRequestIsMerged.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoPullRequestIsMerged.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo&#x27;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner&#x27;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang&#x27;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject&#x27;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book&#x27;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch: async (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['includeDesc'] = includeDesc;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (priorityOwnerId !== undefined) {
                localVarQueryParameter['priority_owner_id'] = priorityOwnerId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (starredBy !== undefined) {
                localVarQueryParameter['starredBy'] = starredBy;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (exclusive !== undefined) {
                localVarQueryParameter['exclusive'] = exclusive;
            }

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoSigningKey.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoSigningKey.');
            }
            const localVarPath = `/repos/{owner}/{repo}/signing-key.gpg`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview: async (body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoSubmitPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoSubmitPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTestHook.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTestHook.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoTestHook.');
            }
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}/tests`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes: async (owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTrackedTimes.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTrackedTimes.');
            }
            const localVarPath = `/repos/{owner}/{repo}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer: async (body: TransferRepoOption, owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoTransfer.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoTransfer.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoTransfer.');
            }
            const localVarPath = `/repos/{owner}/{repo}/transfer`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoUnDismissPullReview.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling repoUnDismissPullReview.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile: async (body: UpdateFileOptions, owner: string, repo: string, filepath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdateFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling repoUpdateFile.');
            }
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest: async (owner: string, repo: string, index: number, style?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdatePullRequest.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdatePullRequest.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling repoUpdatePullRequest.');
            }
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/update`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics: async (owner: string, repo: string, body?: RepoTopicOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling repoUpdateTopics.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling repoUpdateTopics.');
            }
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch: async (q: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling topicSearch.');
            }
            const localVarPath = `/topics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentCheckSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentCheckSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentDeleteSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentDeleteSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userCurrentPutSubscription.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userCurrentPutSubscription.');
            }
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrackedTimes: async (owner: string, repo: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling userTrackedTimes.');
            }
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling userTrackedTimes.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling userTrackedTimes.');
            }
            const localVarPath = `/repos/{owner}/{repo}/times/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication AuthorizationHeaderToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication SudoHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["Sudo"] = localVarApiKeyValue;
            }

            // authentication SudoParam required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("sudo")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["sudo"] = localVarApiKeyValue;
            }

            // authentication TOTPHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-GITEA-OTP")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarHeaderParameter["X-GITEA-OTP"] = localVarApiKeyValue;
            }

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("token")
                    : await configuration.apiKey;
                if (localVarApiKeyValue) localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).acceptRepoTransfer(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).createCurrentUserRepo(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).createFork(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).generateRepo(templateOwner, templateRepo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<AnnotatedTag>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getAnnotatedTag(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GitBlobResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getBlob(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GitTreeResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).getTree(owner, repo, sha, recursive, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Repository>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).listForks(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).rejectRepoTransfer(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddCollaborator(owner, repo, collaborator, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoAddTopic(owner, repo, topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCheckCollaborator(owner, repo, collaborator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Team>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCheckTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Branch>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateBranch(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BranchProtection>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateBranchProtection(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FileResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Hook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateHook(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DeployKey>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateKey(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullRequest>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullRequest(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullReview(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PullReview>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreatePullReviewRequests(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Release>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateRelease(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {Blob} attachment 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachmentForm(attachment: Blob, owner: string, repo: string, id: number, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Attachment>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateReleaseAttachmentForm(attachment, owner, repo, id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CommitStatus>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateStatus(owner, repo, sha, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tag>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateTag(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WikiPage>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoCreateWikiPage(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDelete(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteBranch(owner, repo, branch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteBranchProtection(owner, repo, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteCollaborator(owner, repo, collaborator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FileDeleteResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteGitHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteKey(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeletePullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeletePullReviewRequests(body, owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteRelease(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteReleaseByTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTeam(owner, repo, team, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteTopic(owner, repo, topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDeleteWikiPage(owner, repo, pageName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDismissPullReview(body, owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a commit's diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {string} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: string, binary?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEdit(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BranchProtection>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditBranchProtection(owner, repo, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GitHook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditGitHook(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Hook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditHook(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullRequest>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditPullRequest(owner, repo, index, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Release>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditRelease(owner, repo, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Attachment>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WikiPage>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoEditWikiPage(owner, repo, pageName, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGet(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with &#x27;path&#x27;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Commit>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetAllCommits(owner, repo, sha, path, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetArchive(owner, repo, archive, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<User>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetAssignees(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Branch>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetBranch(owner, repo, branch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BranchProtection>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetBranchProtection(owner, repo, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetByID(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CombinedStatus>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ContentsResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetContents(owner, repo, filepath, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ContentsResponse>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetContentsList(owner, repo, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetEditorConfig(owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GitHook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetGitHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Hook>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<IssueTemplate>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetIssueTemplates(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DeployKey>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetKey(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: number; }>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetLanguages(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Note>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetNote(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullRequest>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullRequest(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Commit>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullRequestCommits(owner, repo, index, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PullReviewComment>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetPullReviewComments(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetRawFile(owner, repo, filepath, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Release>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetRelease(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Attachment>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Release>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetReleaseByTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<User>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetReviewers(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Commit>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetSingleCommit(owner, repo, sha, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tag>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetTag(owner, repo, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WikiPage>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetWikiPage(owner, repo, pageName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WikiCommitList>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetWikiPageRevisions(owner, repo, pageName, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<WikiPageMetaData>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoGetWikiPages(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Reference>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListAllGitRefs(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<BranchProtection>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListBranchProtection(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Branch>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListBranches(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<User>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListCollaborators(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<GitHook>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListGitHooks(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Reference>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListGitRefs(owner, repo, ref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Hook>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListHooks(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<DeployKey>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PullRequest>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PullReview>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListPullReviews(owner, repo, index, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Attachment>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListReleaseAttachments(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Release>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<User>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStargazers(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<CommitStatus>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<CommitStatus>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<User>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListSubscribers(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Tag>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTags(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Team>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTeams(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TopicName>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoListTopics(owner, repo, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMergePullRequest(owner, repo, index, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMigrate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoMirrorSync(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoPullRequestIsMerged(owner, repo, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo&#x27;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner&#x27;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang&#x27;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject&#x27;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book&#x27;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<SearchResults>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, repo, owner, lang, subject, book, includeMetadata, sort, order, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSigningKey(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoSubmitPullReview(body, owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTestHook(owner, repo, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TrackedTime>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Repository>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoTransfer(body, owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PullReview>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUnDismissPullReview(owner, repo, index, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FileResponse>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdateFile(body, owner, repo, filepath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdatePullRequest(owner, repo, index, style, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).repoUpdateTopics(owner, repo, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TopicResponse>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).topicSearch(q, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WatchInfo>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentCheckSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentDeleteSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WatchInfo>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userCurrentPutSubscription(owner, repo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TrackedTime>>>> {
            const localVarAxiosArgs = await RepositoryApiAxiosParamCreator(configuration).userTrackedTimes(owner, repo, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).acceptRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).createFork(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).generateRepo(templateOwner, templateRepo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<AxiosResponse<AnnotatedTag>> {
            return RepositoryApiFp(configuration).getAnnotatedTag(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GitBlobResponse>> {
            return RepositoryApiFp(configuration).getBlob(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<GitTreeResponse>> {
            return RepositoryApiFp(configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Repository>>> {
            return RepositoryApiFp(configuration).listForks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).rejectRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoAddTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoAddTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Team>> {
            return RepositoryApiFp(configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Branch>> {
            return RepositoryApiFp(configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): Promise<AxiosResponse<BranchProtection>> {
            return RepositoryApiFp(configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {CreateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FileResponse>> {
            return RepositoryApiFp(configuration).repoCreateFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Hook>> {
            return RepositoryApiFp(configuration).repoCreateHook(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<AxiosResponse<DeployKey>> {
            return RepositoryApiFp(configuration).repoCreateKey(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): Promise<AxiosResponse<PullRequest>> {
            return RepositoryApiFp(configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {CreatePullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullReview>> {
            return RepositoryApiFp(configuration).repoCreatePullReview(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PullReview>>> {
            return RepositoryApiFp(configuration).repoCreatePullReviewRequests(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Release>> {
            return RepositoryApiFp(configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {Blob} attachment 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachmentForm(attachment: Blob, owner: string, repo: string, id: number, name?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Attachment>> {
            return RepositoryApiFp(configuration).repoCreateReleaseAttachmentForm(attachment, owner, repo, id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): Promise<AxiosResponse<CommitStatus>> {
            return RepositoryApiFp(configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Tag>> {
            return RepositoryApiFp(configuration).repoCreateTag(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<AxiosResponse<WikiPage>> {
            return RepositoryApiFp(configuration).repoCreateWikiPage(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDelete(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {DeleteFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FileDeleteResponse>> {
            return RepositoryApiFp(configuration).repoDeleteFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {PullReviewRequestOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeletePullReviewRequests(body, owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository's tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {DismissPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullReview>> {
            return RepositoryApiFp(configuration).repoDismissPullReview(body, owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit's diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {string} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: string, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return RepositoryApiFp(configuration).repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: string, binary?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return RepositoryApiFp(configuration).repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a repository's properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).repoEdit(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): Promise<AxiosResponse<BranchProtection>> {
            return RepositoryApiFp(configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): Promise<AxiosResponse<GitHook>> {
            return RepositoryApiFp(configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Hook>> {
            return RepositoryApiFp(configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): Promise<AxiosResponse<PullRequest>> {
            return RepositoryApiFp(configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): Promise<AxiosResponse<Release>> {
            return RepositoryApiFp(configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<AxiosResponse<Attachment>> {
            return RepositoryApiFp(configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<AxiosResponse<WikiPage>> {
            return RepositoryApiFp(configuration).repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).repoGet(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with &#x27;path&#x27;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Commit>>> {
            return RepositoryApiFp(configuration).repoGetAllCommits(owner, repo, sha, path, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<User>>> {
            return RepositoryApiFp(configuration).repoGetAssignees(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Branch>> {
            return RepositoryApiFp(configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<AxiosResponse<BranchProtection>> {
            return RepositoryApiFp(configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).repoGetByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit's combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<CombinedStatus>> {
            return RepositoryApiFp(configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ContentsResponse>> {
            return RepositoryApiFp(configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ContentsResponse>>> {
            return RepositoryApiFp(configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoGetEditorConfig(owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GitHook>> {
            return RepositoryApiFp(configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Hook>> {
            return RepositoryApiFp(configuration).repoGetHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<IssueTemplate>>> {
            return RepositoryApiFp(configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository's key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<DeployKey>> {
            return RepositoryApiFp(configuration).repoGetKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: number; }>> {
            return RepositoryApiFp(configuration).repoGetLanguages(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Note>> {
            return RepositoryApiFp(configuration).repoGetNote(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullRequest>> {
            return RepositoryApiFp(configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Commit>>> {
            return RepositoryApiFp(configuration).repoGetPullRequestCommits(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullReview>> {
            return RepositoryApiFp(configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PullReviewComment>>> {
            return RepositoryApiFp(configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Release>> {
            return RepositoryApiFp(configuration).repoGetRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Attachment>> {
            return RepositoryApiFp(configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Release>> {
            return RepositoryApiFp(configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<User>>> {
            return RepositoryApiFp(configuration).repoGetReviewers(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Commit>> {
            return RepositoryApiFp(configuration).repoGetSingleCommit(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Tag>> {
            return RepositoryApiFp(configuration).repoGetTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<WikiPage>> {
            return RepositoryApiFp(configuration).repoGetWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<WikiCommitList>> {
            return RepositoryApiFp(configuration).repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<WikiPageMetaData>>> {
            return RepositoryApiFp(configuration).repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Reference>>> {
            return RepositoryApiFp(configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<BranchProtection>>> {
            return RepositoryApiFp(configuration).repoListBranchProtection(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Branch>>> {
            return RepositoryApiFp(configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<User>>> {
            return RepositoryApiFp(configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<GitHook>>> {
            return RepositoryApiFp(configuration).repoListGitHooks(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository's refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Reference>>> {
            return RepositoryApiFp(configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Hook>>> {
            return RepositoryApiFp(configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<DeployKey>>> {
            return RepositoryApiFp(configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo's pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] State of pull request: open or closed (optional)
         * @param {string} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PullRequest>>> {
            return RepositoryApiFp(configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PullReview>>> {
            return RepositoryApiFp(configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List release's attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Attachment>>> {
            return RepositoryApiFp(configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo's releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Release>>> {
            return RepositoryApiFp(configuration).repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo's stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<User>>> {
            return RepositoryApiFp(configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit's statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CommitStatus>>> {
            return RepositoryApiFp(configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit's statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {string} [sort] type of sort
         * @param {string} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CommitStatus>>> {
            return RepositoryApiFp(configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo's watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<User>>> {
            return RepositoryApiFp(configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Tag>>> {
            return RepositoryApiFp(configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository's teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Team>>> {
            return RepositoryApiFp(configuration).repoListTeams(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<TopicName>> {
            return RepositoryApiFp(configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).repoMigrate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo&#x27;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner&#x27;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang&#x27;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject&#x27;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book&#x27;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<SearchResults>> {
            return RepositoryApiFp(configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, repo, owner, lang, subject, book, includeMetadata, sort, order, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return RepositoryApiFp(configuration).repoSigningKey(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {SubmitPullReviewOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullReview>> {
            return RepositoryApiFp(configuration).repoSubmitPullReview(body, owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoTestHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo's tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TrackedTime>>> {
            return RepositoryApiFp(configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {TransferRepoOption} body Transfer Options
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Repository>> {
            return RepositoryApiFp(configuration).repoTransfer(body, owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<PullReview>> {
            return RepositoryApiFp(configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {UpdateFileOptions} body 
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FileResponse>> {
            return RepositoryApiFp(configuration).repoUpdateFile(body, owner, repo, filepath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge PR's baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TopicResponse>>> {
            return RepositoryApiFp(configuration).topicSearch(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<WatchInfo>> {
            return RepositoryApiFp(configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RepositoryApiFp(configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<AxiosResponse<WatchInfo>> {
            return RepositoryApiFp(configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user's tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TrackedTime>>> {
            return RepositoryApiFp(configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).acceptRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).createFork(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a repository using a template
     * @param {string} templateOwner name of the template repository owner
     * @param {string} templateRepo name of the template repository
     * @param {GenerateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).generateRepo(templateOwner, templateRepo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<AnnotatedTag>> {
        return RepositoryApiFp(this.configuration).getAnnotatedTag(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GitBlobResponse>> {
        return RepositoryApiFp(this.configuration).getBlob(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the &#x27;truncated&#x27; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<GitTreeResponse>> {
        return RepositoryApiFp(this.configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Repository>>> {
        return RepositoryApiFp(this.configuration).listForks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Reject a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).rejectRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoAddTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoAddTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Team>> {
        return RepositoryApiFp(this.configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Branch>> {
        return RepositoryApiFp(this.configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<BranchProtection>> {
        return RepositoryApiFp(this.configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a file in a repository
     * @param {CreateFileOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateFile(body: CreateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FileResponse>> {
        return RepositoryApiFp(this.configuration).repoCreateFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Hook>> {
        return RepositoryApiFp(this.configuration).repoCreateHook(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<DeployKey>> {
        return RepositoryApiFp(this.configuration).repoCreateKey(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullRequest>> {
        return RepositoryApiFp(this.configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a review to an pull request
     * @param {CreatePullReviewOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreatePullReview(body: CreatePullReviewOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullReview>> {
        return RepositoryApiFp(this.configuration).repoCreatePullReview(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary create review requests for a pull request
     * @param {PullReviewRequestOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreatePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PullReview>>> {
        return RepositoryApiFp(this.configuration).repoCreatePullReviewRequests(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Release>> {
        return RepositoryApiFp(this.configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a release attachment
     * @param {Blob} attachment 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateReleaseAttachmentForm(attachment: Blob, owner: string, repo: string, id: number, name?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Attachment>> {
        return RepositoryApiFp(this.configuration).repoCreateReleaseAttachmentForm(attachment, owner, repo, id, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<CommitStatus>> {
        return RepositoryApiFp(this.configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateTagOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tag>> {
        return RepositoryApiFp(this.configuration).repoCreateTag(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) : Promise<AxiosResponse<WikiPage>> {
        return RepositoryApiFp(this.configuration).repoCreateWikiPage(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDelete(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a file in a repository
     * @param {DeleteFileOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteFile(body: DeleteFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FileDeleteResponse>> {
        return RepositoryApiFp(this.configuration).repoDeleteFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {PullReviewRequestOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeletePullReviewRequests(body: PullReviewRequestOptions, owner: string, repo: string, index: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeletePullReviewRequests(body, owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a repository's tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {DismissPullReviewOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDismissPullReview(body: DismissPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullReview>> {
        return RepositoryApiFp(this.configuration).repoDismissPullReview(body, owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a commit's diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha SHA of the commit to get
     * @param {string} diffType whether the output is diff or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return RepositoryApiFp(this.configuration).repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} diffType whether the output is diff or patch
     * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: string, binary?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return RepositoryApiFp(this.configuration).repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a repository's properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).repoEdit(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<BranchProtection>> {
        return RepositoryApiFp(this.configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<GitHook>> {
        return RepositoryApiFp(this.configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Hook>> {
        return RepositoryApiFp(this.configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullRequest>> {
        return RepositoryApiFp(this.configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<Release>> {
        return RepositoryApiFp(this.configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) : Promise<AxiosResponse<Attachment>> {
        return RepositoryApiFp(this.configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Edit a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) : Promise<AxiosResponse<WikiPage>> {
        return RepositoryApiFp(this.configuration).repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGet(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).repoGet(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually &#x27;master&#x27;)
     * @param {string} [path] filepath of a file/dir
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results (ignored if used with &#x27;path&#x27;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Commit>>> {
        return RepositoryApiFp(this.configuration).repoGetAllCommits(owner, repo, sha, path, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<User>>> {
        return RepositoryApiFp(this.configuration).repoGetAssignees(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Branch>> {
        return RepositoryApiFp(this.configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<BranchProtection>> {
        return RepositoryApiFp(this.configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetByID(id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).repoGetByID(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a commit's combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<CombinedStatus>> {
        return RepositoryApiFp(this.configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ContentsResponse>> {
        return RepositoryApiFp(this.configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ContentsResponse>>> {
        return RepositoryApiFp(this.configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetEditorConfig(owner: string, repo: string, filepath: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoGetEditorConfig(owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GitHook>> {
        return RepositoryApiFp(this.configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Hook>> {
        return RepositoryApiFp(this.configuration).repoGetHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<IssueTemplate>>> {
        return RepositoryApiFp(this.configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a repository's key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<DeployKey>> {
        return RepositoryApiFp(this.configuration).repoGetKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: number; }>> {
        return RepositoryApiFp(this.configuration).repoGetLanguages(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Note>> {
        return RepositoryApiFp(this.configuration).repoGetNote(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullRequest>> {
        return RepositoryApiFp(this.configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get commits for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Commit>>> {
        return RepositoryApiFp(this.configuration).repoGetPullRequestCommits(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullReview>> {
        return RepositoryApiFp(this.configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PullReviewComment>>> {
        return RepositoryApiFp(this.configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Release>> {
        return RepositoryApiFp(this.configuration).repoGetRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Attachment>> {
        return RepositoryApiFp(this.configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Release>> {
        return RepositoryApiFp(this.configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<User>>> {
        return RepositoryApiFp(this.configuration).repoGetReviewers(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetSingleCommit(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Commit>> {
        return RepositoryApiFp(this.configuration).repoGetSingleCommit(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tag>> {
        return RepositoryApiFp(this.configuration).repoGetTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<WikiPage>> {
        return RepositoryApiFp(this.configuration).repoGetWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {number} [page] page number of results to return (1-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<WikiCommitList>> {
        return RepositoryApiFp(this.configuration).repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get all wiki pages
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<WikiPageMetaData>>> {
        return RepositoryApiFp(this.configuration).repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get specified ref or filtered repository's refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Reference>>> {
        return RepositoryApiFp(this.configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<BranchProtection>>> {
        return RepositoryApiFp(this.configuration).repoListBranchProtection(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Branch>>> {
        return RepositoryApiFp(this.configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<User>>> {
        return RepositoryApiFp(this.configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<GitHook>>> {
        return RepositoryApiFp(this.configuration).repoListGitHooks(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get specified ref or filtered repository's refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Reference>>> {
        return RepositoryApiFp(this.configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Hook>>> {
        return RepositoryApiFp(this.configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<DeployKey>>> {
        return RepositoryApiFp(this.configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repo's pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] State of pull request: open or closed (optional)
     * @param {string} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array<number>} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListPullRequests(owner: string, repo: string, state?: string, sort?: string, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PullRequest>>> {
        return RepositoryApiFp(this.configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PullReview>>> {
        return RepositoryApiFp(this.configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List release's attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Attachment>>> {
        return RepositoryApiFp(this.configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repo's releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param {boolean} [preRelease] filter (exclude / include) pre-releases
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Release>>> {
        return RepositoryApiFp(this.configuration).repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repo's stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<User>>> {
        return RepositoryApiFp(this.configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a commit's statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {string} [sort] type of sort
     * @param {string} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListStatuses(owner: string, repo: string, sha: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<CommitStatus>>> {
        return RepositoryApiFp(this.configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a commit's statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {string} [sort] type of sort
     * @param {string} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: string, state?: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<CommitStatus>>> {
        return RepositoryApiFp(this.configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repo's watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<User>>> {
        return RepositoryApiFp(this.configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Tag>>> {
        return RepositoryApiFp(this.configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repository's teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Team>>> {
        return RepositoryApiFp(this.configuration).repoListTeams(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<TopicName>> {
        return RepositoryApiFp(this.configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).repoMigrate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [repo] name of the repo. Multiple repo&#x27;s are ORed.
     * @param {string} [owner] owner of the repo. Multiple owner&#x27;s are ORed.
     * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang&#x27;s are ORed.
     * @param {string} [subject] resource subject. Multiple subject&#x27;s are ORed.
     * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book&#x27;s are ORed.
     * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<SearchResults>> {
        return RepositoryApiFp(this.configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, repo, owner, lang, subject, book, includeMetadata, sort, order, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return RepositoryApiFp(this.configuration).repoSigningKey(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {SubmitPullReviewOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoSubmitPullReview(body: SubmitPullReviewOptions, owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullReview>> {
        return RepositoryApiFp(this.configuration).repoSubmitPullReview(body, owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoTestHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoTestHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a repo's tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {Date} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {Date} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoTrackedTimes(owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TrackedTime>>> {
        return RepositoryApiFp(this.configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Transfer a repo ownership
     * @param {TransferRepoOption} body Transfer Options
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoTransfer(body: TransferRepoOption, owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Repository>> {
        return RepositoryApiFp(this.configuration).repoTransfer(body, owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<PullReview>> {
        return RepositoryApiFp(this.configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update a file in a repository
     * @param {UpdateFileOptions} body 
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoUpdateFile(body: UpdateFileOptions, owner: string, repo: string, filepath: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FileResponse>> {
        return RepositoryApiFp(this.configuration).repoUpdateFile(body, owner, repo, filepath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Merge PR's baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} [style] how to update pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TopicResponse>>> {
        return RepositoryApiFp(this.configuration).topicSearch(q, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<WatchInfo>> {
        return RepositoryApiFp(this.configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RepositoryApiFp(this.configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<WatchInfo>> {
        return RepositoryApiFp(this.configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List a user's tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TrackedTime>>> {
        return RepositoryApiFp(this.configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(this.axios, this.basePath));
    }
}
